# golang-notes 
(from : https://www.udemy.com/learn-how-to-code course) and other courses

## Resources 
https://goo.gl/Tbz6Xf
https://docs.google.com/presentation/d/1y0s8O0aApHqxG1vzV__a7mAXN4QiG4gyuGcjzpKGSqg/edit#slide=id.g64448e0de_0_0

An introduction to programming in go 
https://www.golang-book.com/books/intro

Go by example
https://gobyexample.com/


### Why go :
#### Made by geniuses:
* Ken Thomson (B, C, Unix, UTF-8)
* Rob Pike (Unix, UTF-8)
* Robert Grisemer (Hospot, JVM)

* performant
* multiple-cores
* concurrency
* compiled
* network

* clean syntax
* powerful standard library

#### portable 
compiles on many OS's

backed by google
open source

https://golang.org/doc/faq#creating_a_new_language

before go:
https://talks.golang.org/2014/gocon-tokyo.slide#15

fun vs fast:
https://talks.golang.org/2014/gocon-tokyo.slide#16

concurrency and performance
https://talks.golang.org/2014/gocon-tokyo.slide#22

after go:
https://talks.golang.org/2014/gocon-tokyo.slide#28

https://talks.golang.org/2014/gocon-tokyo.slide#31

the creator of web js article : farwell node js
https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b

The more I’ve been working with distributed systems, the more I’m frustrated by Node’s direction, which favours performance over usability and robustness. In the past week I’ve rewritten a relatively large distributed system in Go, and it’s robust, performs better, it’s easier to maintain, and has better test coverage since synchronous code is generally nicer and simpler to work with.

I’m not saying Go is the holy grail, it’s not perfect, but for the languages that exist today Go is a great solution for me. As more of these “next-generation” languages such as Rust and Julia find their place and mature, I’m sure we’ll have a lot more great solutions.

"It’s pretty easy to get by writing entire programs with nearly only consuming the stdlib"







